000100000000
000200000000                Frequently Asked Questions about zlib
000300000000
000400000000
000500000000If your question is not there, please check the zlib home page
000600000000http://www.zlib.org which may have more recent information.
000700000000The lastest zlib FAQ is at http://www.gzip.org/zlib/zlib_faq.html
000800000000
000900000000
001000000000 1. Is zlib Y2K-compliant?
001100000000
001200000000    Yes. zlib doesn't handle dates.
001300000000
001400000000 2. Where can I get a Windows DLL version?
001500000000
001600000000    The zlib sources can be compiled without change to produce a DLL.
001700000000    See the file win32/DLL_FAQ.txt in the zlib distribution.
001800000000    Pointers to the precompiled DLL are found in the zlib web site at
001900000000    http://www.zlib.org.
002000000000
002100000000 3. Where can I get a Visual Basic interface to zlib?
002200000000
002300000000    See
002400000000        * http://www.dogma.net/markn/articles/zlibtool/zlibtool.htm
002500000000        * contrib/visual-basic.txt in the zlib distribution
002600000000        * win32/DLL_FAQ.txt in the zlib distribution
002700000000
002800000000 4. compress() returns Z_BUF_ERROR.
002900000000
003000000000    Make sure that before the call of compress, the length of the compressed
003100000000    buffer is equal to the total size of the compressed buffer and not
003200000000    zero. For Visual Basic, check that this parameter is passed by reference
003300000000    ("as any"), not by value ("as long").
003400000000
003500000000 5. deflate() or inflate() returns Z_BUF_ERROR.
003600000000
003700000000    Before making the call, make sure that avail_in and avail_out are not
003800000000    zero. When setting the parameter flush equal to Z_FINISH, also make sure
003900000000    that avail_out is big enough to allow processing all pending input.
004000000000    Note that a Z_BUF_ERROR is not fatal--another call to deflate() or
004100000000    inflate() can be made with more input or output space. A Z_BUF_ERROR
004200000000    may in fact be unavoidable depending on how the functions are used, since
004300000000    it is not possible to tell whether or not there is more output pending
004400000000    when strm.avail_out returns with zero.
004500000000
004600000000 6. Where's the zlib documentation (man pages, etc.)?
004700000000
004800000000    It's in zlib.h for the moment, and Francis S. Lin has converted it to a
004900000000    web page zlib.html. Volunteers to transform this to Unix-style man pages,
005000000000    please contact us (zlib@gzip.org). Examples of zlib usage are in the files
005100000000    example.c and minigzip.c.
005200000000
005300000000 7. Why don't you use GNU autoconf or libtool or ...?
005400000000
005500000000    Because we would like to keep zlib as a very small and simple
005600000000    package. zlib is rather portable and doesn't need much configuration.
005700000000
005800000000 8. I found a bug in zlib.
005900000000
006000000000    Most of the time, such problems are due to an incorrect usage of
006100000000    zlib. Please try to reproduce the problem with a small program and send
006200000000    the corresponding source to us at zlib@gzip.org . Do not send
006300000000    multi-megabyte data files without prior agreement.
006400000000
006500000000 9. Why do I get "undefined reference to gzputc"?
006600000000
006700000000    If "make test" produces something like
006800000000
006900000000       example.o(.text+0x154): undefined reference to `gzputc'
007000000000
007100000000    check that you don't have old files libz.* in /usr/lib, /usr/local/lib or
007200000000    /usr/X11R6/lib. Remove any old versions, then do "make install".
007300000000
00740000000010. I need a Delphi interface to zlib.
007500000000
007600000000    See the contrib/delphi directory in the zlib distribution.
007700000000
00780000000011. Can zlib handle .zip archives?
007900000000
008000000000    Not by itself, no.  See the directory contrib/minizip in the zlib
008100000000    distribution.
008200000000
00830000000012. Can zlib handle .Z files?
008400000000
008500000000    No, sorry. You have to spawn an uncompress or gunzip subprocess, or adapt
008600000000    the code of uncompress on your own.
008700000000
00880000000013. How can I make a Unix shared library?
008900000000
009000000000    make clean
009100000000    ./configure -s
009200000000    make
009300000000
00940000000014. How do I install a shared zlib library on Unix?
009500000000
009600000000    After the above, then:
009700000000
009800000000    make install
009900000000
010000000000    However, many flavors of Unix come with a shared zlib already installed.
010100000000    Before going to the trouble of compiling a shared version of zlib and
010200000000    trying to install it, you may want to check if it's already there! If you
010300000000    can #include <zlib.h>, it's there. The -lz option will probably link to it.
010400000000
01050000000015. I have a question about OttoPDF.
010600000000
010700000000    We are not the authors of OttoPDF. The real author is on the OttoPDF web
010800000000    site: Joel Hainley, jhainley@myndkryme.com.
010900000000
01100000000016. Can zlib decode Flate data in an Adobe PDF file?
011100000000
011200000000    Yes. See http://www.fastio.com/ (ClibPDF), or http://www.pdflib.com/ .
011300000000    To modify PDF forms, see http://sourceforge.net/projects/acroformtool/ .
011400000000
01150000000017. Why am I getting this "register_frame_info not found" error on Solaris?
011600000000
011700000000    After installing zlib 1.1.4 on Solaris 2.6, running applications using zlib
011800000000    generates an error such as:
011900000000
012000000000        ld.so.1: rpm: fatal: relocation error: file /usr/local/lib/libz.so:
012100000000        symbol __register_frame_info: referenced symbol not found
012200000000
012300000000    The symbol __register_frame_info is not part of zlib, it is generated by
012400000000    the C compiler (cc or gcc). You must recompile applications using zlib
012500000000    which have this problem. This problem is specific to Solaris. See
012600000000    http://www.sunfreeware.com for Solaris versions of zlib and applications
012700000000    using zlib.
012800000000
01290000000018. Why does gzip give an error on a file I make with compress/deflate?
013000000000
013100000000    The compress and deflate functions produce data in the zlib format, which
013200000000    is different and incompatible with the gzip format. The gz* functions in
013300000000    zlib on the other hand use the gzip format. Both the zlib and gzip
013400000000    formats use the same compressed data format internally, but have different
013500000000    headers and trailers around the compressed data.
013600000000
01370000000019. Ok, so why are there two different formats?
013800000000
013900000000    The gzip format was designed to retain the directory information about
014000000000    a single file, such as the name and last modification date. The zlib
014100000000    format on the other hand was designed for in-memory and communication
014200000000    channel applications, and has a much more compact header and trailer and
014300000000    uses a faster integrity check than gzip.
014400000000
01450000000020. Well that's nice, but how do I make a gzip file in memory?
014600000000
014700000000    You can request that deflate write the gzip format instead of the zlib
014800000000    format using deflateInit2(). You can also request that inflate decode
014900000000    the gzip format using inflateInit2(). Read zlib.h for more details.
015000000000
01510000000021. Is zlib thread-safe?
015200000000
015300000000    Yes. However any library routines that zlib uses and any application-
015400000000    provided memory allocation routines must also be thread-safe. zlib's gz*
015500000000    functions use stdio library routines, and most of zlib's functions use the
015600000000    library memory allocation routines by default. zlib's Init functions allow
015700000000    for the application to provide custom memory allocation routines.
015800000000
015900000000    Of course, you should only operate on any given zlib or gzip stream from a
016000000000    single thread at a time.
016100000000
01620000000022. Can I use zlib in my commercial application?
016300000000
016400000000    Yes. Please read the license in zlib.h.
016500000000
01660000000023. Is zlib under the GNU license?
016700000000
016800000000    No. Please read the license in zlib.h.
016900000000
01700000000024. The license says that altered source versions must be "plainly marked". So
017100000000    what exactly do I need to do to meet that requirement?
017200000000
017300000000    You need to change the ZLIB_VERSION and ZLIB_VERNUM #defines in zlib.h. In
017400000000    particular, the final version number needs to be changed to "f", and an
017500000000    identification string should be appended to ZLIB_VERSION. Version numbers
017600000000    x.x.x.f are reserved for modifications to zlib by others than the zlib
017700000000    maintainers. For example, if the version of the base zlib you are altering
017800000000    is "1.2.3.4", then in zlib.h you should change ZLIB_VERNUM to 0x123f, and
017900000000    ZLIB_VERSION to something like "1.2.3.f-zachary-mods-v3". You can also
018000000000    update the version strings in deflate.c and inftrees.c.
018100000000
018200000000    For altered source distributions, you should also note the origin and
018300000000    nature of the changes in zlib.h, as well as in ChangeLog and README, along
018400000000    with the dates of the alterations. The origin should include at least your
018500000000    name (or your company's name), and an email address to contact for help or
018600000000    issues with the library.
018700000000
018800000000    Note that distributing a compiled zlib library along with zlib.h and
018900000000    zconf.h is also a source distribution, and so you should change
019000000000    ZLIB_VERSION and ZLIB_VERNUM and note the origin and nature of the changes
019100000000    in zlib.h as you would for a full source distribution.
019200000000
01930000000025. Will zlib work on a big-endian or little-endian architecture, and can I
019400000000    exchange compressed data between them?
019500000000
019600000000    Yes and yes.
019700000000
01980000000026. Will zlib work on a 64-bit machine?
019900000000
020000000000    It should. It has been tested on 64-bit machines, and has no dependence
020100000000    on any data types being limited to 32-bits in length. If you have any
020200000000    difficulties, please provide a complete problem report to zlib@gzip.org
020300000000
02040000000027. Will zlib decompress data from the PKWare Data Compression Library?
020500000000
020600000000    No. The PKWare DCL uses a completely different compressed data format
020700000000    than does PKZIP and zlib. However, you can look in zlib's contrib/blast
020800000000    directory for a possible solution to your problem.
020900000000
02100000000028. Can I access data randomly in a compressed stream?
021100000000
021200000000    No, not without some preparation. If when compressing you periodically
021300000000    use Z_FULL_FLUSH, carefully write all the pending data at those points,
021400000000    and keep an index of those locations, then you can start decompression
021500000000    at those points. You have to be careful to not use Z_FULL_FLUSH too
021600000000    often, since it can significantly degrade compression.
021700000000
02180000000029. Does zlib work on MVS, OS/390, CICS, etc.?
021900000000
022000000000    We don't know for sure. We have heard occasional reports of success on
022100000000    these systems. If you do use it on one of these, please provide us with
022200000000    a report, instructions, and patches that we can reference when we get
022300000000    these questions. Thanks.
022400000000
02250000000030. Is there some simpler, easier to read version of inflate I can look at
022600000000    to understand the deflate format?
022700000000
022800000000    First off, you should read RFC 1951. Second, yes. Look in zlib's
022900000000    contrib/puff directory.
023000000000
02310000000031. Does zlib infringe on any patents?
023200000000
023300000000    As far as we know, no. In fact, that was originally the whole point behind
023400000000    zlib. Look here for some more information:
023500000000
023600000000    http://www.gzip.org/#faq11
023700000000
02380000000032. Can zlib work with greater than 4 GB of data?
023900000000
024000000000    Yes. inflate() and deflate() will process any amount of data correctly.
024100000000    Each call of inflate() or deflate() is limited to input and output chunks
024200000000    of the maximum value that can be stored in the compiler's "unsigned int"
024300000000    type, but there is no limit to the number of chunks. Note however that the
024400000000    strm.total_in and strm_total_out counters may be limited to 4 GB. These
024500000000    counters are provided as a convenience and are not used internally by
024600000000    inflate() or deflate(). The application can easily set up its own counters
024700000000    updated after each call of inflate() or deflate() to count beyond 4 GB.
024800000000    compress() and uncompress() may be limited to 4 GB, since they operate in a
024900000000    single call. gzseek() and gztell() may be limited to 4 GB depending on how
025000000000    zlib is compiled. See the zlibCompileFlags() function in zlib.h.
025100000000
025200000000    The word "may" appears several times above since there is a 4 GB limit
025300000000    only if the compiler's "long" type is 32 bits. If the compiler's "long"
025400000000    type is 64 bits, then the limit is 16 exabytes.
025500000000
02560000000033. Does zlib have any security vulnerabilities?
025700000000
025800000000    The only one that we are aware of is potentially in gzprintf(). If zlib
025900000000    is compiled to use sprintf() or vsprintf(), then there is no protection
026000000000    against a buffer overflow of a 4K string space, other than the caller of
026100000000    gzprintf() assuring that the output will not exceed 4K. On the other
026200000000    hand, if zlib is compiled to use snprintf() or vsnprintf(), which should
026300000000    normally be the case, then there is no vulnerability. The ./configure
026400000000    script will display warnings if an insecure variation of sprintf() will
026500000000    be used by gzprintf(). Also the zlibCompileFlags() function will return
026600000000    information on what variant of sprintf() is used by gzprintf().
026700000000
026800000000    If you don't have snprintf() or vsnprintf() and would like one, you can
026900000000    find a portable implementation here:
027000000000
027100000000        http://www.ijs.si/software/snprintf/
027200000000
027300000000    Note that you should be using the most recent version of zlib. Versions
027400000000    1.1.3 and before were subject to a double-free vulnerability.
027500000000
02760000000034. Is there a Java version of zlib?
027700000000
027800000000    Probably what you want is to use zlib in Java. zlib is already included
027900000000    as part of the Java SDK in the java.util.zip package. If you really want
028000000000    a version of zlib written in the Java language, look on the zlib home
028100000000    page for links: http://www.zlib.org/
028200000000
02830000000035. I get this or that compiler or source-code scanner warning when I crank it
028400000000    up to maximally-pedantic. Can't you guys write proper code?
028500000000
028600000000    Many years ago, we gave up attempting to avoid warnings on every compiler
028700000000    in the universe. It just got to be a waste of time, and some compilers
028800000000    were downright silly. So now, we simply make sure that the code always
028900000000    works.
029000000000
02910000000036. Valgrind (or some similar memory access checker) says that deflate is
029200000000    performing a conditional jump that depends on an uninitialized value.
029300000000    Isn't that a bug?
029400000000
029500000000    No.  That is intentional for performance reasons, and the output of
029600000000    deflate is not affected.  This only started showing up recently since
029700000000    zlib 1.2.x uses malloc() by default for allocations, whereas earlier
029800000000    versions used calloc(), which zeros out the allocated memory.
029900000000
03000000000037. Will zlib read the (insert any ancient or arcane format here) compressed
030100000000    data format?
030200000000
030300000000    Probably not. Look in the comp.compression FAQ for pointers to various
030400000000    formats and associated software.
030500000000
03060000000038. How can I encrypt/decrypt zip files with zlib?
030700000000
030800000000    zlib doesn't support encryption. The original PKZIP encryption is very weak
030900000000    and can be broken with freely available programs. To get strong encryption,
031000000000    use GnuPG, http://www.gnupg.org/ , which already includes zlib compression.
031100000000    For PKZIP compatible "encryption", look at http://www.info-zip.org/
031200000000
03130000000039. What's the difference between the "gzip" and "deflate" HTTP 1.1 encodings?
031400000000
031500000000    "gzip" is the gzip format, and "deflate" is the zlib format. They should
031600000000    probably have called the second one "zlib" instead to avoid confusion
031700000000    with the raw deflate compressed data format. While the HTTP 1.1 RFC 2616
031800000000    correctly points to the zlib specification in RFC 1950 for the "deflate"
031900000000    transfer encoding, there have been reports of servers and browsers that
032000000000    incorrectly produce or expect raw deflate data per the deflate
032100000000    specficiation in RFC 1951, most notably Microsoft. So even though the
032200000000    "deflate" transfer encoding using the zlib format would be the more
032300000000    efficient approach (and in fact exactly what the zlib format was designed
032400000000    for), using the "gzip" transfer encoding is probably more reliable due to
032500000000    an unfortunate choice of name on the part of the HTTP 1.1 authors.
032600000000
032700000000    Bottom line: use the gzip format for HTTP 1.1 encoding.
032800000000
03290000000040. Does zlib support the new "Deflate64" format introduced by PKWare?
033000000000
033100000000    No. PKWare has apparently decided to keep that format proprietary, since
033200000000    they have not documented it as they have previous compression formats.
033300000000    In any case, the compression improvements are so modest compared to other
033400000000    more modern approaches, that it's not worth the effort to implement.
033500000000
03360000000041. Can you please sign these lengthy legal documents and fax them back to us
033700000000    so that we can use your software in our product?
033800000000
033900000000    No. Go away. Shoo.
